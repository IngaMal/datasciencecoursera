---
title: "R course (Coursera)"
author: "IngaMal"
date: \today
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# R Programming

Заметки по курсу 

## GitHub

Обновление локальной рабочей директории с git:

1. Заходим в рабочую директорию: cd D:/Coursera/R/datasciencecoursera
2. Проверяем на основную (master): git checkout master
3. Обновляем: git pull
4. Выходим: exit


## Week 1. Background, Getting Started, and Nuts & Bolts

Проверка рабочей директории:

```{r}
getwd()
```
Файлы в рабочей директории:

```{r}
dir()
```
'<-' - оператор присваивания
```{r}
x <- 10
print(x)
x+1
y <- 1:50
y
```

**Objects**: basic classes:

0. character
0. numeric (real numbers, т.е. double precision real numbers)
0. integer (добавление метки L при создании, к примеру '1L')
0. complex
0. logical (True/False)

Базовый объект *вектор (vector)* состоит из объектов одного типа (инача только *список (list)*). Пустой вектор может быть создан функцией vector().

Специальные объекты:

 - *Inf* - бесконечность или 1/0. Значением 1/Inf будет 0.
 - *NaN* - отсутствующее значение или неопределенное значение (0 / 0). NaN - неопределенное математически выражение, NA - всё остальное
```{r}
1
1L
1/0
1/Inf
0/0
#Test Nan/NA
x <- c(1, 2, NaN, NA, 4)
is.na(x)#показывает NA и NaN
is.nan(x)#показывает только NaN
```
 
 Объекты могут иметь *attributes* (атрибуты), такие как имя, длина, размерность (к примеру матрица, массив) и другие. Функция attributes().
 
 Несколько примеров:
```{r}
x <- c(0.5, 0.6)       ## numeric
x <- c(TRUE, FALSE)    ## logical
x <- c(T, F)           ## logical
x <- c("a", "b", "c")  ## character
x <- 9:29             ## integer
x <- c(1+0i, 2+4i)     ## complex
x <- vector("numeric", length = 10)##using vector() function
x
```
 
 При попытке объединить объекты разных типов в вектор наступает *coercion*, которую можно решить используя функции типа *as.type()*:
```{r}
y <- c(1.7, "a")
class(y)
x <- 5:9
class(x)
as.numeric(x)
as.logical(x)
```
 
 List:
```{r}
x <- list(1, "a", TRUE, 1 + 4i) 
x
```
 
 Матрица -- вектор с атрибутом размерности. The dimension attribute is itself an integer vector oflength 2 (nrow, ncol). Заполнение поколоночное, начиная с левого верхнего угла
```{r}
m <- matrix(nrow = 2, ncol = 3)
m
dim(m)
attributes(m)
#Create new matrix
m <- matrix(1:6, nrow = 2, ncol = 3) #заполнение матрицы
m
```
 Также можно создать сначала вектор, а потом добавить атрибут:
```{r}
m <- 1:20
m
dim(m) <- c(4, 5)
m
```
 Рассмотрим также слияние матриц колонками (cbind) и строками (rbind):
```{r}
x <- 1:3
y <- 10:12
cbind(x, y)
rbind(x, y)
```
 
 **Factors** используют для категориальных данных, которые могут быть упорядоченными или нет:
```{r}
x <- factor(c("yes", "yes", "no", "yes", "no")) 
x
table(x)
unclass(x)
attr(x,"levels")
y <- factor(c("yes", "yes", "no", "yes", "no"),              
            levels = c("yes", "no"))
y
```
 
 *Таблица данных*. Каждая колонна - вектор:
```{r}
x <- data.frame(foo = 1:4, bar = c(T, T, F, F)) 
nrow(x)
ncol(x)

```
 
 *Имена*
```{r}
x <- 1:3
names(x)
names(x) <- c("foo", "bar", "norf") 
x
names(x)

m <- matrix(1:4, nrow = 2, ncol = 2)
dimnames(m) <- list(c("a", "b"), c("c", "d"))
m
```
 
### Test
```{r}
dat <- read.csv(file = "hw1_data.csv", header = TRUE)

#11. In the dataset provided for this Quiz, what are the column names of the dataset
names(dat)
#12. Extract the first 2 rows of the data frame and print them to the console. What does the output look like?
head(data, 2)
#13. How many observations (i.e. rows) are in this data frame?
nrow(dat)
#14. Extract the last 2 rows of the data frame and print them to the console. What does the output look like?
dat[152:153,] ##or tail(dat)
#15. What is the value of Ozone in the 47th row?
dat[47,1]
#16. How many missing values are in the Ozone column of this data frame?
table(is.na(dat[,1]))
#17. What is the mean of the Ozone column in this dataset? Exclude missing values (coded as NA) from this calculation.
good <- complete.cases(dat)
mean(dat[good, ][,1])
#18. Extract the subset of rows of the data frame where Ozone values are above 31 and Temp values are above 90. What is the mean of Solar.R in this subset?
mean(subset(dat, Ozone > 31 & Temp > 90)$Solar.R)
#19. What is the mean of "Temp" when "Month" is equal to 6? 
mean(subset(dat, Month == 6)$Temp)
#20. What was the maximum ozone value in the month of May (i.e. Month is equal to 5)?
max(subset(dat, Month == 5)$Ozone, na.rm = TRUE)
```
 
### Practical R Exercises in swirl Part 1
```{r}
#Вызов тестовых заданий
#install.packages("swirl")
library(swirl)
install_from_swirl("R Programming")
swirl()
```

## Week 2. Programming with R

Распространённые структуры:

0. **if, else**: testing a condition
0. **for**: execute a loop a fixed number of times
0. ***while**: execute a loop while a condition is true
0. **repeat**: execute an infinite loop
0. **break**: break the execution of a loop
0. **next**: skip an interation of a loop
0. **return**: exit a function

Конструкция *if else*:
if(<condition>) {
        ## do something
} else {
        ## do something else
}
Можно и так:
```{r}
x <- 4
y <- if(x > 3) {10} else { 0 }
y
x <- 1
y <- if(x > 3) {10} else { 0 }
y
```

Конструкция *for*:
```{r}
for (i in 1:10){
        print(i)
}
#same behaviour
x <- c("a", "b", "c", "d")
for(i in seq_along(x)) {
        print(x[i])
}
for(letter in x) {
        print(letter)
}
for(i in 1:4) print(x[i])
```

Конструкция *while*. Опасность зацикливания.
```{r}
count <- 0
while(count < 10) {
        print(count)
        count <- count + 1
}
```
*Random walk*:
```{r}
z <- 5
while(z >= 3 && z <= 10) {
        print(z)
        coin <- rbinom(1, 1, 0.5)
        if(coin == 1) {  ## random walk
                z <- z + 1        
        } else {
                z <- z - 1        
        } 
}
```
Конструкции *repeat* и *break*. Опасность зацикливания.
```{r}
x0 <- 1
tol <- 1e-8
repeat {
        x1 <- x0 - tol/2 * rbinom(1, 1, 0.5)
        if(abs(x1 - x0) < tol) {
                break
        } else {
                x0 <- x1
        } 
}
```
Конструкция *next* используется для пропуска итерации в цикле, **return* сигнализирует о выходе из функции и возвращении значения.


*Function*
```{r}
add2 <- function(x,y){
        x+y
}
above <- function(x, n = 10){#defold number n = 10
        x[x>n]
}
column_mean <- function(data_frame, removeNA = TRUE){
        nc <- ncol(data_frame)
        means <- numeric(nc)
        for (i in 1:nc){
                means[i] <- mean(data_frame[,i], na.rm = removeNA)
        }
        means #return last expression of the function
}
# "..." argument is often used when extending another function and you don’t want to copy the entire argumentlist of the original function
# One  catch  with  ...  is  that  any  arguments  that  appear after  ...  on  the  argument  list  must  be  namedexplicitly and cannot be partially matched.
myplot <- function(x, y, type = "l", ...) {
        plot(x, y, type = type, ...)
        }
```
