---
title: "R course (Coursera)"
author: "IngaMal"
date: \today
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# R Programming

Заметки по курсу 

## GitHub

Обновление локальной рабочей директории с git:

1. Заходим в рабочую директорию: cd D:/Coursera/R/datasciencecoursera
2. Проверяем на основную (master): git checkout master
3. Обновляем: git pull
4. Выходим: exit


## Week 1. Background, Getting Started, and Nuts & Bolts

Проверка рабочей директории:

```{r}
getwd()
```
Файлы в рабочей директории:

```{r}
dir()
```
'<-' - оператор присваивания
```{r}
x <- 10
print(x)
x+1
y <- 1:50
y
```

**Objects**: basic classes:

0. character
0. numeric (real numbers, т.е. double precision real numbers)
0. integer (добавление метки L при создании, к примеру '1L')
0. complex
0. logical (True/False)

Базовый объект *вектор (vector)* состоит из объектов одного типа (инача только *список (list)*). Пустой вектор может быть создан функцией vector().

Специальные объекты:

 - *Inf* - бесконечность или 1/0. Значением 1/Inf будет 0.
 - *NaN* - отсутствующее значение или неопределенное значение (0 / 0). NaN - неопределенное математически выражение, NA - всё остальное
```{r}
1
1L
1/0
1/Inf
0/0
#Test Nan/NA
x <- c(1, 2, NaN, NA, 4)
is.na(x)#показывает NA и NaN
is.nan(x)#показывает только NaN
```
 
 Объекты могут иметь *attributes* (атрибуты), такие как имя, длина, размерность (к примеру матрица, массив) и другие. Функция attributes().
 
 Несколько примеров:
```{r}
x <- c(0.5, 0.6)       ## numeric
x <- c(TRUE, FALSE)    ## logical
x <- c(T, F)           ## logical
x <- c("a", "b", "c")  ## character
x <- 9:29             ## integer
x <- c(1+0i, 2+4i)     ## complex
x <- vector("numeric", length = 10)##using vector() function
x
```
 
 При попытке объединить объекты разных типов в вектор наступает *coercion*, которую можно решить используя функции типа *as.type()*:
```{r}
y <- c(1.7, "a")
class(y)
x <- 5:9
class(x)
as.numeric(x)
as.logical(x)
```
 
 List:
```{r}
x <- list(1, "a", TRUE, 1 + 4i) 
x
```
 
 Матрица -- вектор с атрибутом размерности. The dimension attribute is itself an integer vector oflength 2 (nrow, ncol). Заполнение поколоночное, начиная с левого верхнего угла
```{r}
m <- matrix(nrow = 2, ncol = 3)
m
dim(m)
attributes(m)
#Create new matrix
m <- matrix(1:6, nrow = 2, ncol = 3) #заполнение матрицы
m
```
 Также можно создать сначала вектор, а потом добавить атрибут:
```{r}
m <- 1:20
m
dim(m) <- c(4, 5)
m
```
 Рассмотрим также слияние матриц колонками (cbind) и строками (rbind):
```{r}
x <- 1:3
y <- 10:12
cbind(x, y)
rbind(x, y)
```
 
 **Factors** используют для категориальных данных, которые могут быть упорядоченными или нет:
```{r}
x <- factor(c("yes", "yes", "no", "yes", "no")) 
x
table(x)
unclass(x)
attr(x,"levels")
y <- factor(c("yes", "yes", "no", "yes", "no"),              
            levels = c("yes", "no"))
y
```
 
 *Таблица данных*. Каждая колонна - вектор:
```{r}
x <- data.frame(foo = 1:4, bar = c(T, T, F, F)) 
nrow(x)
ncol(x)

```
 
 *Имена*
```{r}
x <- 1:3
names(x)
names(x) <- c("foo", "bar", "norf") 
x
names(x)

m <- matrix(1:4, nrow = 2, ncol = 2)
dimnames(m) <- list(c("a", "b"), c("c", "d"))
m
```
 
### Test
```{r}
dat <- read.csv(file = "hw1_data.csv", header = TRUE)

#11. In the dataset provided for this Quiz, what are the column names of the dataset
names(dat)
#12. Extract the first 2 rows of the data frame and print them to the console. What does the output look like?
head(data, 2)
#13. How many observations (i.e. rows) are in this data frame?
nrow(dat)
#14. Extract the last 2 rows of the data frame and print them to the console. What does the output look like?
dat[152:153,] ##or tail(dat)
#15. What is the value of Ozone in the 47th row?
dat[47,1]
#16. How many missing values are in the Ozone column of this data frame?
table(is.na(dat[,1]))
#17. What is the mean of the Ozone column in this dataset? Exclude missing values (coded as NA) from this calculation.
good <- complete.cases(dat)
mean(dat[good, ][,1])
#18. Extract the subset of rows of the data frame where Ozone values are above 31 and Temp values are above 90. What is the mean of Solar.R in this subset?
mean(subset(dat, Ozone > 31 & Temp > 90)$Solar.R)
#19. What is the mean of "Temp" when "Month" is equal to 6? 
mean(subset(dat, Month == 6)$Temp)
#20. What was the maximum ozone value in the month of May (i.e. Month is equal to 5)?
max(subset(dat, Month == 5)$Ozone, na.rm = TRUE)
```
 
### Practical R Exercises in swirl Part 1
```{r}
#Вызов тестовых заданий
#install.packages("swirl")
library(swirl)
install_from_swirl("R Programming")
#swirl()
```

## Week 2. Programming with R

Распространённые структуры:

0. **if, else**: testing a condition
0. **for**: execute a loop a fixed number of times
0. ***while**: execute a loop while a condition is true
0. **repeat**: execute an infinite loop
0. **break**: break the execution of a loop
0. **next**: skip an interation of a loop
0. **return**: exit a function

Конструкция *if else*:
if(<condition>) {
        ## do something
} else {
        ## do something else
}
Можно и так:
```{r}
x <- 4
y <- if(x > 3) {10} else { 0 }
y
x <- 1
y <- if(x > 3) {10} else { 0 }
y
```

Конструкция *for*:
```{r}
for (i in 1:10){
        print(i)
}
#same behaviour
x <- c("a", "b", "c", "d")
for(i in seq_along(x)) {
        print(x[i])
}
for(letter in x) {
        print(letter)
}
for(i in 1:4) print(x[i])
```

Конструкция *while*. Опасность зацикливания.
```{r}
count <- 0
while(count < 10) {
        print(count)
        count <- count + 1
}
```
*Random walk*:
```{r}
z <- 5
while(z >= 3 && z <= 10) {
        print(z)
        coin <- rbinom(1, 1, 0.5)
        if(coin == 1) {  ## random walk
                z <- z + 1        
        } else {
                z <- z - 1        
        } 
}
```
Конструкции *repeat* и *break*. Опасность зацикливания.
```{r}
x0 <- 1
tol <- 1e-8
repeat {
        x1 <- x0 - tol/2 * rbinom(1, 1, 0.5)
        if(abs(x1 - x0) < tol) {
                break
        } else {
                x0 <- x1
        } 
}
```
Конструкция *next* используется для пропуска итерации в цикле, **return* сигнализирует о выходе из функции и возвращении значения.


*Function*
```{r}
add2 <- function(x,y){
        x+y
}
above <- function(x, n = 10){#defold number n = 10
        x[x>n]
}
column_mean <- function(data_frame, removeNA = TRUE){
        nc <- ncol(data_frame)
        means <- numeric(nc)
        for (i in 1:nc){
                means[i] <- mean(data_frame[,i], na.rm = removeNA)
        }
        means #return last expression of the function
}
# "..." argument is often used when extending another function and you don’t want to copy the entire argumentlist of the original function
# One  catch  with  ...  is  that  any  arguments  that  appear after  ...  on  the  argument  list  must  be  namedexplicitly and cannot be partially matched.
myplot <- function(x, y, type = "l", ...) {
        plot(x, y, type = type, ...)
        }
```

### Practica R
```{r}
#Напишите функцию с именем «pollutantmean», которая вычисляет среднее значение 
#загрязнителя (сульфат или нитрат) по указанному списку наблюдений.
#Функция 'pollutantmean' принимает три аргумента: 'directory', 'pollutant' и 'id'.
#Учитывая идентификационные номера векторных наблюдений, 'pollutantmean' 
#считывает данные мониторинга твердых частиц из каталога, указанного в аргументе 'directory',
#и возвращает среднее значение загрязняющего вещества по всем наблюдениям, 
#игнорируя все пропущенные значения, закодированные как NA.

pollutantmean <- function(directory, pollutant, id = 1:332){
  files <- list.files(directory, pattern = ".csv", full.names = TRUE) #все файлы в директории
  mydata <- data.frame()#пустая таблица

  for(i in id){
    temp <- read.csv(files[i], header = TRUE)#выбираем интересующие данные
    mydata <- rbind(mydata, temp)#добавляем в таблицу
  }

  mean(mydata[, pollutant], na.rm = TRUE)#среднее без пропущенных значений
}
```

```{r}
# Write a function that reads a directory full of files and reports the number of 
# completely observed cases in each data file. The function should return a data frame 
# where the first column is the name of the file and the second column is the number 
# of complete cases.

complete <- function(directory, id = 1:332){
  files <- list.files(directory, pattern = ".csv", full.names = TRUE) #все файлы в директории
  mydata <- data.frame()#пустая таблица
  
  for(i in id){
    temp <- read.csv(files[i], header = TRUE)#выбираем интересующую таблицу
    sm <- sum(!is.na(temp$sulfate)&!is.na(temp$nitrate))
    temp <- c(i, sm)
    
    mydata <- rbind(mydata, temp)#добавляем в таблицу
  }
  names(mydata) <- c("id", "nobs")#добавляем имена столбцов
  mydata
}
```

```{r}
# Напишите функцию, которая берет каталог файлов данных и пороговое значение для завершенных 
# наблюдений и вычисляет корреляцию между сульфатом и нитратом для местоположений наблюдения,
# где число полностью наблюдаемых наблюдений (по всем переменным) превышает пороговое значение.
# Функция должна возвращать вектор корреляций для наблюдений, которые удовлетворяют пороговому
# требованию. Если ни одно из наблюдений не удовлетворяет пороговому требованию, то 
# функция должна возвращать числовой вектор длины 0.

corr <- function(directory, threshold = 0){
  files <- list.files(directory, pattern = ".csv", full.names = TRUE) #все файлы в директории
  levels <- complete(directory)$nobs  #все пороги
  myvector <- vector(mode = "numeric")#пустой вектор
  
  for(i in 1:length(files)){
    if (levels[i] > threshold){
      temp <- read.csv(files[i], header = TRUE) #выбираем интересующую таблицу
      myvector <- c(myvector, cor(temp$sulfate, temp$nitrate,use="na.or.complete"))
    }
  }
  myvector
}
```

## Week 3. Loop Functions and Debugging

 - *lapply*: Loop over a list and evaluate a function on each element
 - *sapply*: Same as lapply but try to simplify the result
 - *apply*: Apply a function over the margins of an array
 - *tapply*: Apply a function over subsets of a vector
 - *mapply*: Multivariate version of lapply
 
```{r}
x <- list(a = 1:6, b = rnorm(10))
lapply(x, mean) #считает среднее для каждого элемента из листа x
?runif#The Uniform Distribution

tabl <- list(a = matrix(1:4, 2, 2), b = matrix(1:6, 3, 2)) 
tabl
lapply(tabl, function(elt) elt[,1])
```
Отличия *saplly* от *lapply*:
- If the result is a list where every element is length 1, then a vector is returned.
- If the result is a list where every element is a vector of the same length (> 1), a matrix is returned.
- If it can’t figure things out, a list is returned
```{r}
x <- list(a = 1:4, b = rnorm(10), c = rnorm(20, 1), d = rnorm(100, 5))
lapply(x, mean)
sapply(x, mean) 
mean(x)
```

```{r}
x <- matrix(rnorm(200), 20, 10)#20 строк, 10 матриц
head(x)
apply(x, 2, mean)#среднее по каждой колонне
apply(x, 1, sum)#сумма по каждой строке
```
- *rowSums* = apply(x, 1, sum)
- *rowMeans* = apply(x, 1, mean)
- *colSums* = apply(x, 2, sum)
- *colMeans* = apply(x, 2, mean)

```{r}
a <- array(rnorm(2 * 2 * 10), c(2, 2, 10))
apply(a, c(1, 2), mean)
rowMeans(a, dims = 2)#equivivalent
```
```{r}
list(rep(1, 4), rep(2, 3), rep(3, 2), rep(4, 1))#rep(1,4) - повторить '1' 4 раза
mapply(rep, 1:4, 4:1)
```

```{r}
x <- c(rnorm(10), runif(10), rnorm(10, 1))
f <- gl(3, 10)#10 единиц, 10 двоек, 10 троек
tapply(x, f, mean)
tapply(x, f, mean, simplify = FALSE)
tapply(x, f, range)
```

*split*  takes  a  vector  or  other  objects  and  splits  it  into  groups determined  by  a  factor  or  list  of factors

**Debugging Tools**:
The primary tools for debugging functions in R are
- *traceback*: prints out the function call stack after an error occurs; does nothing if there’s no error
- *debug*: flags a function for “debug” mode which allows you to step through execution of a function one line at a time
- **browser*:  suspends  the  execution  of  a  function  wherever  it  is  called  and  puts  the  function  indebug mode
- *trace*: allows you to insert debugging code into a function a specific places
- *recover*: allows you to modify the error behavior so that you can browse the function call stack

### Test
```{r}
#1. In this dataset, what is the mean of 'Sepal.Length' for the species virginica? Please round your answer to the nearest whole number.
library(datasets)
data(iris)
s <- split(iris, iris$Species)
sapply(s$virginica, mean)
round(sapply(s$virginica, mean))

#2. Continuing with the 'iris' dataset from the previous Question, what R code returns a vector of the means of the variables 'Sepal.Length', 'Sepal.Width', 'Petal.Length', and 'Petal.Width'?
apply(iris[, 1:4], 2, mean)

#3. How can one calculate the average miles per gallon (mpg) by number of cylinders in the car (cyl)?
library(datasets)
data(mtcars)
tapply(mtcars$mpg, mtcars$cyl, mean)
with(mtcars, tapply(mpg, cyl , mean))
sapply(split(mtcars$mpg, mtcars$cyl), mean)

#4. Continuing with the 'mtcars' dataset from the previous Question, what is the absolute difference between the average horsepower(hp) of 4-cylinder cars and the average horsepower of 8-cylinder cars?
t <- tapply(mtcars$hp, mtcars$cyl, mean)
round(t[3] - t[1])
```

